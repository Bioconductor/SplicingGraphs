%\VignetteIndexEntry{Splicing graph analysis of RNA-Seq data}
%\VignetteDepends{SplicingGraphs,TxDb.Mmusculus.UCSC.mm9.knownGene,TBX20BamSubset,Rsamtools}
%\VignetteKeywords{Annotation}
%\VignettePackage{SplicingGraphs}
\documentclass[11pt]{article}

\usepackage{url}
\usepackage{float}
\usepackage{xcolor}

\usepackage[margin=1in]{geometry}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}

\bibliographystyle{plainnat}

\SweaveOpts{keep.source=TRUE}

\title{Splicing graph analysis of RNA-Seq data}

\author{Martin Morgan\and
  Marc Carlson\and
  Daniel Bindreither\and
  Herv\'e Pag\`es}

\date{Last modified: March 2013; Compiled: \today}

\begin{document}

\maketitle

<<settings,echo=FALSE>>=
.precomputed_results <- system.file("doc", "precomputed_results",
                                    package="SplicingGraphs", mustWork=TRUE)
.loadPrecomputed <- function(objname)
{
    filename <- paste0(objname, ".rda")
    path <- file.path(.precomputed_results, filename)
    tempenv <- new.env(parent=emptyenv())
    load(path, envir=tempenv)
    get(objname, envir=tempenv)
}
@ 

\tableofcontents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \Rpackage{SplicingGraphs} package creates splicing 
graphs \cite{Sammeth:2010} based on a given annotation 
provided as \Rclass{TranscriptDb} or \Rclass{GRangesList} 
objects. An already published RNA-Seq experiment is used
to demonstrate the usage of the \Rpackage{SplicingGraphs} package. 
The utilized study, performed in \textit{Mus musculus}, compares 
TBX20 (T-box protein 20) knock-out with wilde type heart 
tissue samples \cite{Sakabe:2012}. The presented workflow 
analyzes the data set in terms of differential alternative splicing. 
Although there exist several software solutions for RNA-Seq 
based transcriptome analysis, like RSEM \cite{RSEM2011},
Cufflinks \cite{Roberts:2011} or the R package \Rpackage{DEXSeq} 
\cite{Anders:2010}, the approach of analyzing splicing events as
complete complex structure is still new. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Splicing graphs}

Alternative splicing is a frequently observed complex biological 
process which modifies the primary RNA transcript and leads to 
transcript variants of genes. Those variants can often be plentiful. 
Especially for large genes it is often difficult to describe their
structure in a formal, logical, short and convenient way. To capture 
the full variety of splicing variants of a certain gene in one single 
data structure Heber at al \cite{Heber:2002} introduced the term 
splicing graph and provided a formal frame work for representing
the different choices of the splicing machinery. 

Splicing graphs in general are directed acyclic graphs (DAGs) and
consist of two main structure elements designated as vertices 
and edges. Vertices represent different types of sites at the annotated 
transcripts and edges, connecting the vertices, represent the respective 
exonic and intronic structure. Wether the edge is representing an exon 
or an intron is determined by the types of the two flanking vertices. 
Vertices according \cite{Heber:2002} can be of type 
acceptor splicing site ($-$), donor splicing site ($\wedge$), transcript start 
site ($~[~$) or transcript end ($~]~$).  For the correctness of the splicing 
graph framework artificial sites designated as root ($R$) and leaf ($L$) 
attached to the start and the end of each graph are required. It is important 
to note that root and leaf will never represent real observed sites at the 
transcripts and act just as a common sources and sink of the splicing graph. 
The symbols associated with the individual types of vertices shown in braces 
above are used for the identification of complete alternative splicing events.
For details about gathering the alternative splicing events and their
associated splicing codes see \cite{Heber:2002} and 
\cite{Sammeth:2010}.

Figure \ref{img:CIB3} shows the splicing graph representation
of all known transcript variants of Human gene CIB3 (Entrez ID 117286).

\begin{figure}[tbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=90,origin=lB]{CIB3-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the four transcript variants
    of gene CIB3 (Entrez ID 117286).
    Left: transcript representation. Right: splicing graph representation.
    The orange arrows are edges corresponding to exons.
  }
  \label{img:CIB3}
\end{figure}

\subsection{Details about vertices and edges}

In many cases one vertex can represent two different types of sites, but
the combinations of types for such vertices is limited. 
Only splicing site acceptors ($-$) and transcript start sites ($~[~$) or
splicing site donors ($\wedge$) and transcript ends ($~]~$) can occur as
a pair of site types.
Such a two-type vertex occurs when the start of an exon, which is not
the first exon of a transcript falls together with the
transcription start site of another transcript of the same gene.
An example of such splicing graph is shown in Figure \ref{img:ZNF813}.

\begin{figure}[tbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=-90,origin=rB]{ZNF813-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=3in,height=5.5in]{ZNF813-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the two transcript variants
    of Human gene ZNF813 (Entrez ID 126017). Node $3$ is a two-type vertex:
    splicing site acceptor ($-$) for transcript {\tt uc002qbu.2},
    and transcript start site ($~[~$) for transcript {\tt uc010eqq.1}.
  }
  \label{img:ZNF813}
\end{figure}

A similar case occurs when the end of an exon, which is not the last
exon of a transcript falls together with the transcript
end of another transcript isoform belonging to the same gene. 
As mentioned above the edges can either represent introns or exons
depending on the types of the flanking vertices.
An edge between a splicing site acceptor ($-$) and a splice site donor
($\wedge$) vertex for example would represent an exon whereas the edge
between a splicing site donor ($\wedge$) and an splicing site acceptor ($-$)
would represent an intron.
Exons are also described between transcription start sites ($~[~$) and splicing
site donors ($\wedge$) or splicing site acceptors ($-$) and transcript
ends ($~]~$). The edges between the root vertex ($R$) and the transcription
start sites ($~[~$) as well as the edges between the transcript 
ends ($~]~$) and the leaf ($L$) contain neither an
intron nor an exon because such edges contain usually no 
sequence information at all.

\subsection{Uninformative nodes}

Not all splicing sites (vertices) on the individual transcripts are alternative 
splicing sites. Therefore the initial splicing graph outlined above can be
simplified by removing vertices of in- and out- degree equal to one because
they are supposed to be non-informative in terms of alternative splicing.
Edges associated with such vertices get sequentially merged with
the previous ones and result in longer edges capturing several exons.
The final splicing graph only contains vertices involved in alternative
splicing. The process of removing uninformative nodes is illustrated in
Figure \ref{img:CIB3-simplified}.

\begin{figure}[tbp]
  \begin{center}
  \includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}
  \hskip 0.5in
  \includegraphics[width=2in,height=5.5in]{CIB3-sg2.pdf}
  \end{center}
  \caption{Nodes $1$, $3$, $5$, $6$, $9$, $11$, $12$, and $13$ are
    uninformative and can be removed.
    Left: before removal of the uninformative nodes. Right: after their
    removal.
  }
  \label{img:CIB3-simplified}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Create splicing graphs from annotations}

As outlined in the previous section the splicing graph approach
extends the differential expression analysis of single exons
implemented by in \Rpackage{DEXSeq} towards
the analysis of a priori known alternative splicing events.
The starting point for creating a splicing graph is a
\Rclass{TranscriptDb} object containing all required gene 
and transcript annotation of a certain reference genome.
Here the \Rpackage{TxDb.Mmusculus.UCSC.mm9.knownGenee} 
package is used.

If other annotations are needed such objects can easily be
created by using functions of the \Rpackage{GenomicFeatures} 
package.

First we load the selected \Rclass{TranscriptDb} object.

<<txdb>>=
library(TxDb.Mmusculus.UCSC.mm9.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm9.knownGene
@

Creating a splicing graph for the whole \Rclass{TranscriptDb}
object usually takes about 20 minutes if the information 
about the types of alternative splicing events is retrieved on a normal 
desktop computer. If only the edges of the splicing graph are retrieved
the computation time shortens to about 5 minutes for the 
whole \Rclass{TranscriptDb} object.
To save some time we utilize only chromosome 19. 
To run the \Rfunction{SplicingGraphs} constructor only on a subset of
the \Rclass{TranscriptDb} object the \Rpackage{GenomicFeatures}
package provides the \Rfunction{isActiveSeq} function
to deactivate chromosomes in the \Rclass{TranscriptDb} object which should
not be used. Usually one would deactivate random
chromosomes often found in the annotation.

<<isActiveSeq>>=
activeChr <- setNames(rep(FALSE, length(isActiveSeq(txdb))),
                      names(isActiveSeq(txdb)))
activeChr[names(activeChr) == "chr19"] <- TRUE
isActiveSeq(txdb) <- activeChr
@

Finally we can call the \Rfunction{SplicingGraphs} constructor on
the modified \Rclass{TranscriptDb} object.

<<sg>>=
library(SplicingGraphs)
sg <- SplicingGraphs(txdb)
sg
@
%% We load a precomputed 'sg' that contains all the bubbles in its
%% bubbles_cache slot.
<<loadPrecomputed_sg,echo=FALSE>>=
sg2 <- .loadPrecomputed("sg")
sg@.bubbles_cache <- sg2@.bubbles_cache
if (!identical(sg, sg2))
    stop("'sg' is not identical to precomputed version")
@

\Rcode{sg} is a \Rclass{SplicingGraphs} object. It has 1 element per
gene and \Rcode{sg} gives the gene ids.

<<names_sg>>=
names(sg)[1:20]
@

The transcripts of a given gene can be extracted as an \emph{unnamed}
\Rclass{GRangesList} object with \Rfunction{[[}:

<<sg_double_bracket_107328>>=
sg[["107328"]]
@

and plotted with \Rfunction{plotTranscripts}:

<<plotTranscripts_sg_107328,eval=FALSE>>=
plotTranscripts(sg[["107328"]])
@

The resulting plot is shown on figure \ref{img:107328-transcripts}.

<<plotTranscripts_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-transcripts.pdf", width=6, height=3)
plotTranscripts(sg[["107328"]])
dev.off()
@
\begin{figure}[tbp]
  \begin{center}
  \includegraphics[width=6in,height=3in]{107328-transcripts.pdf}
  \end{center}
  \caption{The 3 transcripts of gene 107328 (Entrez ID).}
  \label{img:107328-transcripts}
\end{figure}

The transcripts of all the genes can be extracted as a \emph{named}
\Rclass{GRangesList} object with \Rfunction{unlist}:

<<unlist_sg>>=
unlist(sg)
@

The edges and nodes of the splicing graph of a given gene can be
extracted with \Rfunction{sgedges} and \Rfunction{sgnodes} applied
on the subsetted \Rclass{SplicingGraphs} object:

<<sgedges_sg>>=
sgedges(sg["107328"])
sgnodes(sg["107328"])
@

Alternatively the edges of all the genes can be extracted with
\Rfunction{sgedgesByTranscript}. They are returned in a
\Rclass{GRangesList} object where they are grouped by transcript.
Note that only the \emph{internal} edges are returned i.e.
edges starting from the root node ($R$) or ending at the leaf
node ($L$) are omitted:

<<sgedgesByTranscript_sg>>=
sgedgesByTranscript(sg)
@

To plot a given splicing graph:

<<plot_sg_107328,eval=FALSE>>=
plot(sgraph(sg["107328"]))
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
@

The resulting plots are shown on figure \ref{img:107328-sgraph}.

<<plot_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-sgraph.pdf", width=3, height=5)
plot(sgraph(sg["107328"]))
dev.off()
pdf("107328-sgraph-labelled.pdf", width=3, height=5)
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
dev.off()
@
\begin{figure}[tbp]
  \begin{center}
  \includegraphics[width=3in,height=5in]{107328-sgraph.pdf}
  \hskip 0.25in
  \includegraphics[width=3in,height=5in]{107328-sgraph-labelled.pdf}
  \end{center}
  \caption{Splicing graph representation of gene 107328 (Entrez ID).
    Left: unlabelled edges. Right: edge labelled with the transcript
    ids (or names).
  }
  \label{img:107328-sgraph}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph bubbles}

Each graph in \Rcode{sg} contains information about the underlying splicing
mechanisms for the corresponding gene. This information can be summarized
by extracting the bubbles of a graph.

\subsection{Extract the bubbles}

<<bubbles_sg_107328>>=
bubbles(sg["107328"])
@

[TODO: Describe the output of bubbles().]

\subsection{Interpretation of the alternative splicing codes}

[TODO: Revisit this subsection entirely.]

Splicing codes can be obtained by iterating over the individual
bubbles and collecting the types of the original vertices associated 
with the individual bubble edges and their ranks. This section
makes use of simple toy examples to describe how the splicing code can 
be interpreted in terms of well known splicing mechanisms like exon 
skipping, alternative promotor usage, intron retention, etc.

An example read out of a bubble could reveal the splicing code 
($1~0~0~2~1 - 2~2~\wedge$ ) which would represent an 1 exon skip. 
See Figure \ref{img:exskip}.
The first part of the code ($1~0~0$) indicates that the first edge
contains no exon at all. The first symbol of this code part
indicates the edge number, the second symbol the vertex rank within 
the bubble and the third symbol the vertex type. The second part of 
the splicing code ($2~1 - 2~2~\wedge$) represents edge number 2 
containing exactly one exon described by the flanking vertices
$-$ and $\wedge$. 

\begin{figure}[H]
  \begin{center}
  \includegraphics[width=\textwidth]{exskip.png}
  \end{center}
  \caption{Splicing graph representation of an 1 exon skip leading to
    one bubble. The associated splicing code is 
    $1~0~0~2~1 - 2~2~\wedge$. Left: splicing graph
    representation. Right: transcript representation
  }
  \label{img:exskip}
\end{figure}

Another example where disjoining comes into play is a
an alternative splicing site acceptor in one of two transcripts.
The code for an alternative splicing site acceptor would be 
$1~0~0~2~1 - 2~2~{\wedge}{:}$ and can be seen as an exon 
skip where the end of the exon is linked to a disjoint site. 
In such a way it is possible to characterize and to
distinguish a variety of different splicing events. 
See Figure \ref{img:altaccept}

\begin{figure}[H]
  \begin{center}
  \includegraphics[width=\textwidth]{altaccept.png}
  \end{center}
  \caption{Splicing graph representation of an alternative acceptor site
    leading to one bubble. The associated splicing code is
    $1~0~0~2~1 - 2~2~{\wedge}{:}$. 
    Left: splicing graph representation. Right: transcript representation
  }
  \label{img:altaccept}
\end{figure}

\subsection{Tabulating all the alternative splicing codes for Mouse
            chromosome 19}

<<AScode_summary>>=
AScode_list <- lapply(seq_along(sg), function(i) bubbles(sg[i])$AScode)
names(AScode_list) <- names(sg)
AScode_table <- table(unlist(AScode_list))
AScode_table <- sort(AScode_table, decreasing=TRUE)
AScode_summary <- data.frame(AScode=names(AScode_table),
                             NbOfEvents=as.vector(AScode_table),
                             Desciption=ASCODE2DESC[names(AScode_table)])
nrow(AScode_summary)
head(AScode_summary, n=10)
@

Amongst the \Sexpr{nrow(AScode_summary)} distinct complete events we observe
on Mouse chromosome 19, the most frequent one is named ``skip 1 exon''.
At this point it should be mentioned that not all splicing
events have names since there are a variety of different events.

Another interesting information which we can gain from the splicing
graph is how many complete events does each individual gene have.
To answer this we have to count the number of bubbles within
each gene.

<<nb_bubbles_per_gene>>=
nb_bubbles_per_gene <- elementLengths(AScode_list)
@ 

Below the genes with the most observed splicing events are shown.

<<head_sort_nb_bubbles_per_gene>>=
head(sort(nb_bubbles_per_gene, decreasing=TRUE))
@ 

Next we want to see which genes show the highest heterogeneity of splicing
events.
We check for the number of unique splicing events for each gene.

<<nb_unique_bubbles_per_gene>>=
nb_unique_bubbles_per_gene <- elementLengths(unique(CharacterList(AScode_list)))
@ 

Below the genes with the highest heterogeneity in observed splicing events
are shown

<<head_sort_nb_unique_bubbles_per_gene>>=
head(sort(nb_unique_bubbles_per_gene, decreasing=TRUE))
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Counting reads}

[TODO: Complete this section.]

This section deals with counting the reads associated with the
individual edges. To elucidate later in this vignette some
advantages of the splicing graph approach the reads for the 
exon model get also counted. As a starting point for counting the 
aligned reads are required. The aligned reads used in this example 
are stored as BAM files. The BAM files used for counting reads are
provided in the \Rpackage{TBX20BamSubset}.
The \Rfunction{countSpliceGraphReads} function 
requires a \Rclass{BamFileList} object which is created out of the
the file paths to the six selected BAM files.

<<bam_files>>=
library(TBX20BamSubset)
bam_files <- getBamFileList()
@ 

\subsection{Assigning reads to a \Rclass{SplicingGraphs} object}

We can use the \Rcode{assignReads} function to assign reads to the
exons and introns in \Rclass{SplicingGraphs} object \Rcode{sg}.
Note that the same read can be assigned to more than one exon or
intron (e.g. a junction read with 1 gap can be assigned to 2 exons
and 1 intron).

[TODO: Try to optimize assignReads() so we can do the full count below
 in reasonable time.]

In order to keep things running in a reasonable time in this vignette,
we reduce the size of \Rclass{SplicingGraphs} object \Rcode{sg} by
keeping only 50 randomly chosen genes:

<<sg50>>=
set.seed(33)
sg50 <- sample(sg, 50)
@

We're also going to use only 20\% (randomly sampled) of the reads
from each BAM file.

<<assignReads,eval=FALSE>>=
library(Rsamtools)
flag0 <- scanBamFlag(isNotPrimaryRead=FALSE,
                     isNotPassingQualityControls=FALSE,
                     isDuplicate=FALSE)
param0 <- ScanBamParam(flag=flag0)
## The following loop takes about 10 minutes!
for (i in seq_along(bam_files)) {
    bam_file <- bam_files[i]
    cat("Processing sample ", names(bam_file), " ... ", sep="")
    gal0 <- readGappedAlignments(bam_file, use.names=TRUE, param=param0)
    gal <- sample(gal0, length(gal0) * 0.2)
    grl <- grglist(gal, order.as.in.query=TRUE)
    sg50 <- assignReads(sg50, grl, sample.name=names(bam_file))
    cat("OK\n")
}
@
<<loadPrecomputed_sg50,echo=FALSE>>=
sg50 <- .loadPrecomputed("sg50")
@

\subsection{Counting the number of reads per splicing graph edge}

<<countReads_sg50,eval=FALSE>>=
## Takes about 1 minute...
sg50_counts <- countReads(sg50)
@
<<loadPrecomputed_sg50_counts,echo=FALSE>>=
sg50_counts <- .loadPrecomputed("sg50_counts")
@

The returned object is a \Rclass{DataFrame} with one row per unique
splicing graph edge and one column of counts per sample. Two additional
columns contain the splicing graph edge ids and the type of edge (exon
or intron):

\begin{small}
<<head_sg50_counts>>=
dim(sg50_counts)
head(sg50_counts)
@
\end{small}

[NOTE: Topics/sections in the old SpliceGraph vignette not covered here:
 ``The experimental design''; ``Significant altered alternative splice
 events''; modification of GLM employed in the \Rpackage{DEXSeq} package;
 ``Differential edge expression analysis''; comparison to the classic
 \Rpackage{DEXSeq} analysis]
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session Information}

All of the output in this vignette was produced under the following
conditions:

<<SessionInfo>>=
toLatex(sessionInfo())
@


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{}

\bibitem{Sammeth:2010}
{Michael Sammeth}.
\newblock Complete Alternative Splicing Events Are Bubbles in Splicing Graphs
\newblock {\em Computational Biology}, \textbf{16}, 1117-1140, 2010.

\bibitem{Sakabe:2012}
{Sakabe, Noboru J.} and {Aneas, Ivy} and {Shen, Tao} and {Shokri, Leila} and {Park, Soo-Young} and {Bulyk, Martha L.} and {Evans, Sylvia M.} and {Nobrega, Marcelo A.}
\newblock Dual transcriptional activator and repressor roles of TBX20 regulate adult cardiac structure and function
\newblock {\em Human Molecular Genetics}, \textbf{21}(10), 2194-2204, 2012.

\bibitem{RSEM2011}
{LI, Bo} and {Dewey, Colin}.
\newblock RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome
\newblock {\em BMC Bioinformatics}, \textbf{12}(1), 323, 2011.

\bibitem{Roberts:2011}
{Roberts, Adam} and {Pimentel, Harold} and {Trapnell, Cole} and {Pachter, Lior}.
\newblock Identification of novel transcripts in annotated genomes using RNA-Seq
\newblock {\em BIOINFORMATICS}, 2011

\bibitem{Anders:2010}
{Simon Anders} and {Wolfgang Huber}.
\newblock {D}ifferential expression analysis for sequence count data
\newblock {\em Genome Biology}, \textbf{11}, R106, 2010.

\bibitem{Heber:2002}
{Heber, Steffen} and {Alekseyev, Max} and {Sze, Sing-Hoi} and {Tang, Haixu} and {Pevzner, Pavel A.}
\newblock Splicing graphs and EST assembly problem
\newblock {\em Bioinformatics}, \textbf{18}(suppl 1), S181-S188, 2002.

\end{thebibliography}

\end{document}

