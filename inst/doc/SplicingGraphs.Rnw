%\VignetteIndexEntry{Splicing graph analysis of RNA-Seq data}
%\VignetteDepends{SplicingGraphs,TxDb.Mmusculus.UCSC.mm9.knownGene,TBX20BamSubset,Rsamtools}
%\VignetteKeywords{Annotation}
%\VignettePackage{SplicingGraphs}
\documentclass[11pt]{article}

\usepackage{url}
\usepackage{float}
\usepackage{xcolor}

\usepackage[margin=1in]{geometry}

\setlength{\parindent}{0pt}

\usepackage{enumitem}
\setlist{nolistsep}

\usepackage[margin=0.75in]{caption}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\bibliographystyle{plainnat}

\SweaveOpts{keep.source=TRUE}

\title{Splicing graph analysis of RNA-Seq data}

\author{Martin Morgan\and
  Marc Carlson\and
  Daniel Bindreither\and
  Herv\'e Pag\`es}

\date{Last modified: March 2013; Compiled: \today}

\begin{document}

\maketitle

<<settings,echo=FALSE>>=
.precomputed_results <- system.file("doc", "precomputed_results",
                                    package="SplicingGraphs", mustWork=TRUE)
.loadPrecomputed <- function(objname)
{
    filename <- paste0(objname, ".rda")
    path <- file.path(.precomputed_results, filename)
    tempenv <- new.env(parent=emptyenv())
    load(path, envir=tempenv)
    get(objname, envir=tempenv)
}
@ 

\tableofcontents

\setlength{\parskip}{\baselineskip}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \Rpackage{SplicingGraphs} package allows the user to create and
manipulate splicing graphs \cite{Sammeth:2010} based on annotations
for a given organism. The annotations must describe a \textit{gene model},
that is, they must contain the following information:
\begin{itemize}
  \item The exact exon/intron structure (i.e. genomic coordinates)
        for the known transcripts.
  \item The grouping of transcripts by gene.
\end{itemize}

The annotations need to be provided as a \Rclass{TranscriptDb} or
\Rclass{GRangesList} object, which is how a gene model is typically
represented in \Bioconductor.

Additionally the package allows the user to assign RNA-Seq reads to
a SplicingGraphs object, and to count them. This requires that the
reads have been previously aligned to the exact same reference genome
that the gene model is based on. RNA-Seq data from an already published
study is used to illustrate this functionality. The study, performed on
\textit{Mus musculus}, compares TBX20 (T-box protein 20) knock-out
with wilde type heart tissue samples \cite{Sakabe:2012}.

%Although there exist several software solutions for RNA-Seq 
%based transcriptome analysis, like RSEM \cite{RSEM2011},
%Cufflinks \cite{Roberts:2011} or the R package \Rpackage{DEXSeq} 
%\cite{Anders:2010}, the approach of analyzing splicing events as
%complete complex structure is still new. 

[TODO: Remove the following TEMPORARY NOTE before BioC 2.12 release.]

TEMPORARY NOTE: The scope of the new \Rpackage{SplicingGraphs} package
has been reduced roughly to the following functionalities:
creating/manipulating/plotting splicing graphs, computing the bubbles
and AS codes, and counting reads. In particular anything in the old
\Rpackage{SpliceGraph} package that was related to the downstream
statistical analysis has been dropped. As a consequence the following
topics/sections from the old \Rpackage{SpliceGraph} vignette are not
covered in this vignette:
\begin{itemize}
  \item ``The experimental design''
  \item ``Significant altered alternative splice events''
  \item Modification of GLM employed in the \Rpackage{DEXSeq} package.
  \item ``Differential edge expression analysis''
  \item Comparison to the classic \Rpackage{DEXSeq} analysis.
\end{itemize}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Splicing graphs}

Alternative splicing is a frequently observed complex biological 
process which modifies the primary RNA transcript and leads to 
transcript variants of genes. Those variants can often be plentiful. 
Especially for large genes it is often difficult to describe their
structure in a formal, logical, short and convenient way. To capture 
the full variety of splicing variants of a certain gene in one single 
data structure, Heber at al \cite{Heber:2002} introduced the term 
\textit{splicing graph} and provided a formal framework for representing
the different choices of the splicing machinery. 

\subsection{Definitions and example}

For a comprehensive explanation of the splicing graph theory,
please refer to \cite{Heber:2002} and \cite{Sammeth:2010}.

A splicing graph is a directed acyclic graph (DAG) where:
\begin{itemize}
  \item The vertices (a.k.a. \textit{nodes}) represent the splicing sites
        for a given gene. Splicing sites are numbered from $1$ to $n$
        based on their order of appearance when moving in the 5' to 3'
        direction along the strand where the transcripts are located.
        Note that splicing graphs are only defined for genes that have all
        the exons of all their transcripts on the same chromosome and
        strand. In particular, in its current form, the splicing graph
        theory cannot describe \textit{trans-plicing} events.
  \item The edges are the exons and introns between the splicing sites.
        Their orientation follows the 5' to 3' direction i.e. they go
        from low to high splicing site numbers.
\end{itemize}

Two artificial nodes that don't correspond to any splicing site
are added to the graph: the root ($R$) and the leaf ($L$). Also artificial
edges are added so that all the transcripts are represented by a path that
goes from $R$ to $L$. That way the graph is connected. Note that not all
paths in the graph are necessarily supported by a transcript.

Figure \ref{img:CIB3} shows the splicing graph representation
of all known transcript variants of Human gene CIB3 (Entrez ID 117286).

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=90,origin=lB]{CIB3-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the four transcript variants
    of gene CIB3 (Entrez ID 117286).
    Left: transcript representation. Right: splicing graph representation.
    The orange arrows are edges corresponding to exons.
  }
  \label{img:CIB3}
\end{figure}

\subsection{Details about nodes and edges}

Splicing sites can be of the following types:
\begin{itemize}
  \item \textit{acceptor} site (symbol: $-$);
  \item \textit{donor} site (symbol: $\wedge$);
  \item \textit{transcription start} site (symbol: $~[~$);
  \item \textit{transcription end} site (symbol: $~]~$).
\end{itemize}

The symbols associated with the individual types of nodes shown in braces 
above are used for the identification of complete alternative splicing
events. For more information about gathering the alternative splicing
events and their associated splicing codes, please refer to
\cite{Heber:2002} and \cite{Sammeth:2010}.

In some cases a given splicing site can be associated with 2 types
but the combinations of types for such sites is limited.
Only \textit{acceptor} ($-$) and \textit{transcription start} ($~[~$),
or \textit{donor} ($\wedge$) and \textit{transcription end} ($~]~$), can
occur as a pair of types. Such a dual-type node occurs when the start
of an exon, which is not the first exon of a transcript, falls together
with the transcription start site of another transcript of the same gene.
An example of such splicing graph is shown in Figure \ref{img:ZNF813}.

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=-90,origin=rB]{ZNF813-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=3in,height=5.5in]{ZNF813-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the two transcript variants
    of Human gene ZNF813 (Entrez ID 126017). Node $3$ is a ($-$,$~[~$)
    dual-type node: \textit{acceptor} ($-$) for transcript {\tt uc002qbu.2},
    and \textit{transcription start} ($~[~$) for transcript {\tt uc010eqq.1}.
  }
  \label{img:ZNF813}
\end{figure}

A similar case occurs when the end of an exon, which is not the last
exon of a transcript, falls together with the transcription end site
of another transcript of the same gene.

Whether a non-artificial edge represents an exon or an intron is
determined by the types of its two flanking nodes:
\begin{itemize}
  \item \textbf{exon} if going from \textit{acceptor} ($-$), or
        ($-$,$~[~$) dual-type, to \textit{donor} ($\wedge$), or
        ($\wedge$,$~]~$) dual-type;
  \item \textbf{intron} if the otherway around.
\end{itemize}

\subsection{Uninformative nodes}

Not all splicing sites (nodes) on the individual transcripts are alternative 
splicing sites. Therefore the initial splicing graph outlined above can be
simplified by removing nodes of in- and out- degree equal to one because
they are supposed to be non-informative in terms of alternative splicing.
Edges associated with such nodes get sequentially merged with
the previous ones and result in longer edges capturing adjacent
exons/introns. The final splicing graph only contains nodes involved in
alternative splicing. The result of removing uninformative nodes is
illustrated in Figure \ref{img:CIB3-simplified}.

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}
  \hskip 0.5in
  \includegraphics[width=2in,height=5.5in]{CIB3-sg2.pdf}
  \end{center}
  \caption{Nodes $1$, $3$, $5$, $6$, $9$, $11$, $12$, and $13$ are
    uninformative and can be removed.
    Left: before removal of the uninformative nodes. Right: after their
    removal.
  }
  \label{img:CIB3-simplified}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing splicing graphs from annotations}


\subsection{Choosing and loading a gene model}

The starting point for computing splicing graphs is a set of annotations
describing a \textit{gene model} for a given organism. In \Bioconductor,
a gene model is typically represented as a \Rclass{TranscriptDb}.
A few prepackaged \Rclass{TranscriptDb} objects are available as
\Rpackage{TxDb.*} annotation packages in the \Bioconductor package
repositories. Here the \Rpackage{TxDb.Mmusculus.UCSC.mm9.knownGene}
package is used. Note that if there is no prepackaged \Rclass{TranscriptDb}
object for the genome/track that the user wants to use, such objects can
easily be created by using tools from the \Rpackage{GenomicFeatures} 
package.

First we load the \Rpackage{TxDb.*} package:

<<txdb>>=
library(TxDb.Mmusculus.UCSC.mm9.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm9.knownGene
@

Creating the splicing graphs for all the genes in the \Rclass{TranscriptDb}
object can take a long time (up to 20 minutes or more). In order to keep
things running in a reasonable time in this vignette, we restrict the gene
model to the genes located on chromosome 19. Let's use the
\Rfunction{isActiveSeq} getter/setter for this. By default, all the
chromosomes in a \Rclass{TranscriptDb} object are ``active'':

\begin{small}
<<isActiveSeq>>=
isActiveSeq(txdb)
@
\end{small}

Next we set all the values in this named logical vector to \Rcode{FALSE},
except the value for \Rcode{chr19}:

<<keep_chr19_only>>=
isActiveSeq(txdb)[-match("chr19", names(isActiveSeq(txdb)))] <- FALSE
names(which(isActiveSeq(txdb)))
@

\subsection{Generating a \Rclass{SplicingGraphs} object}

Splicing graphs are computed by calling the \Rfunction{SplicingGraphs}
function on the gene model. This is the constructor function for
\Rclass{SplicingGraphs} objects. It will compute information about all
the splicing graphs (1 per gene) and store it in the returned object.

<<sg>>=
library(SplicingGraphs)
sg <- SplicingGraphs(txdb)
sg
@
%% We load a precomputed 'sg' that contains all the bubbles in its
%% bubbles_cache slot.
<<loadPrecomputed_sg,echo=FALSE>>=
sg2 <- .loadPrecomputed("sg")
sg@.bubbles_cache <- sg2@.bubbles_cache
if (!identical(sg, sg2))
    stop("'sg' is not identical to precomputed version")
@

\Rcode{sg} is a \Rclass{SplicingGraphs} object. It has 1 element per
gene and \Rcode{names(sg)} gives the gene ids:

<<names_sg>>=
names(sg)[1:20]
@

\Rcode{seqnames(sg)} and \Rcode{strand(sg)} return the chromosome and
strand of the genes:

<<seqnames_sg>>=
seqnames(sg)[1:20]
strand(sg)[1:20]
@

The number of transcripts per gene can be obtained with
\Rcode{elementLengths(sg)}:

<<elementLengths_sg>>=
elementLengths(sg)[1:20]
@

\Rfunction{elementLengths} is a core accessor for list-like objects
that returns

At this point you might wonder why \Rfunction{elementLengths} works on
\Rclass{SplicingGraphs} object. Does this mean that those objects are
list-like objects? The answer is yes. The next thing you might wonder
is what do the list elements look like and how can I access them?
This is answered in the next subsection.

\subsection{Basic manipulation of a \Rclass{SplicingGraphs} object}

The list elements of a list-like object can be accessed \textbf{one at a
time} with \Rfunction{[[}. On a \Rclass{SplicingGraphs} object, this will
extract the transcripts of a given gene. More precisely it will return
an \emph{unnamed} \Rclass{GRangesList} object containing the exons grouped
by transcript:

\begin{small}
<<sg_double_bracket_107328>>=
sg[["107328"]]
@
\end{small}

The exon-level metadata columns are:
\begin{itemize}
  \item \Rcode{exon\_id}: The original internal exon id as stored in the
        \Rclass{TranscriptDb} object. This id was created and assigned to
        each exon when the \Rclass{TranscriptDb} object was created.
        It's not a public id like, say, an Ensembl, RefSeq, or GenBank id,
        and it's only guaranteed to be unique within a \Rclass{TranscriptDb}
        object.
  \item \Rcode{exon\_name}: The original exon name as provided by the
        annotation resource (e.g. UCSC, Ensembl, or GFF file) and stored
        in the \Rclass{TranscriptDb} object when it was created.
        \Rcode{NA} if no exon name was provided.
  \item \Rcode{exon\_rank}: The rank of the exon in the transcript.
  \item \Rcode{start\_SSid}, \Rcode{end\_SSid}: The ids of the splicing
        sites corresponding to the start and end coordinates of the exon.
        Those ids were assigned by the \Rfunction{SplicingGraphs} constructor.
        IMPORTANT NOTE: Please keep in mind that the start and end
        coordinates of an exon, like the start and end coordinates of
        a genomic range in general, are following the almost universal
        convention that $start$ is $<= end$, and this \textbf{regardless
        of the direction of transcription}.
\end{itemize}

As mentioned previously, the splicing site ids are assigned based on their
order of appearance when moving in the 5' to 3' direction along the strand
of the gene. This means that, for a gene on the plus (resp. minus) strand,
the ids in the \Rcode{start\_SSid} metadata column are always lower (resp.
greater) than those in the \Rcode{end\_SSid} metadata column:

\begin{small}
<<sg_double_bracket_104252>>=
sg[["104252"]]
@
\end{small}

However, on both strands, the splicing site id increases with the
rank of the exon.

The \Rfunction{show} method for \Rclass{GRangesList} objects only
displays the inner metadata columns (which are at the exon level for
objects like \Rcode{sg[["107328"]]}). To see the outer metadata columns
(transcript-level metadata columns for objects like \Rcode{sg[["107328"]]}),
we need to extract them explicitely:

<<mcols_sg_double_bracket_107328>>=
mcols(sg[["107328"]])
@

The transcript-level metadata columns are:
\begin{itemize}
  \item \Rcode{tx\_id}: The original transcript id as provided by the
        annotation resource (e.g. UCSC, Ensembl, or GFF file) and stored
        in the \Rclass{TranscriptDb} object when it was created.
  \item \Rcode{txpaths}: A named list-like object with one list element
        per transcript. Each list element is an integer vector that
        describes the \textit{path} of the transcript i.e. the splicing
        site ids that it goes thru.
\end{itemize}

<<mcols_sg_double_bracket_107328>>=
mcols(sg[["107328"]])$txpaths
mcols(sg[["104252"]])$txpaths
@

Note that the list elements of the \Rcode{txpaths} metadata column
always consist of an even number of splicing site ids in ascending
order.

The transcripts in a \Rclass{GRangesList} object like \Rcode{sg[["107328"]]}
can be plotted with \Rfunction{plotTranscripts}:

<<plotTranscripts_sg_107328,eval=FALSE>>=
plotTranscripts(sg[["107328"]])
@

The resulting plot is shown on figure \ref{img:107328-transcripts}.

<<plotTranscripts_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-transcripts.pdf", width=6, height=3)
plotTranscripts(sg[["107328"]])
dev.off()
@
\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=6in,height=3in]{107328-transcripts.pdf}
  \end{center}
  \caption{The 3 transcripts of gene 107328 (Entrez ID).}
  \label{img:107328-transcripts}
\end{figure}

\Rclass{SplicingGraphs} objects, like most list-like objects, can be
unlisted with \Rfunction{unlist}. This will extract the transcripts of
all the genes and return them as a \emph{named} \Rclass{GRangesList} object:

<<unlist_sg>>=
unlist(sg)
@

\subsection{Extracting and plotting graphs from a \Rclass{SplicingGraphs}
            object}

The edges and nodes of the splicing graph of a given gene can be
extracted with \Rfunction{sgedges} and \Rfunction{sgnodes} applied
on the subsetted \Rclass{SplicingGraphs} object:

<<sgedges_sg>>=
sgedges(sg["107328"])
sgnodes(sg["107328"])
@

Alternatively the edges of all the genes can be extracted with
\Rfunction{sgedgesByTranscript}. They are returned in a
\Rclass{GRangesList} object where they are grouped by transcript.
Note that the artificial edges (i.e. edges starting from the root
node ($R$) or ending at the leaf node ($L$)) are omitted:

<<sgedgesByTranscript_sg>>=
sgedgesByTranscript(sg)
@

To plot a given splicing graph:

<<plot_sg_107328,eval=FALSE>>=
plot(sgraph(sg["107328"]))
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
@

The resulting plots are shown on figure \ref{img:107328-sgraph}.

<<plot_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-sgraph.pdf", width=3, height=5)
plot(sgraph(sg["107328"]))
dev.off()
pdf("107328-sgraph-labelled.pdf", width=3, height=5)
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
dev.off()
@
\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=3in,height=5in]{107328-sgraph.pdf}
  \hskip 0.25in
  \includegraphics[width=3in,height=5in]{107328-sgraph-labelled.pdf}
  \end{center}
  \caption{Splicing graph representation of gene 107328 (Entrez ID).
    Left: unlabelled edges. Right: edge labelled with the transcript
    ids (or names).
  }
  \label{img:107328-sgraph}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Graph bubbles}

Each graph in \Rcode{sg} contains information about the underlying splicing
mechanisms for the corresponding gene. This information can be summarized
by computing the bubbles of a graph.

\subsection{Computing the bubbles of a splicing graph}

<<bubbles_sg_107328>>=
bubbles(sg["107328"])
@

[TODO: Describe the output of bubbles().]

\subsection{Interpretation of the alternative splicing codes}

[TODO: Revisit this subsection entirely.]

Splicing codes can be obtained by iterating over the individual
bubbles and collecting the types of the original nodes associated 
with the individual bubble edges and their ranks. This section
makes use of simple toy examples to describe how the splicing code can 
be interpreted in terms of well known splicing mechanisms like exon 
skipping, alternative promotor usage, intron retention, etc.

An example read out of a bubble could reveal the splicing code 
($1~0~0~2~1 - 2~2~\wedge$ ) which would represent an 1 exon skip. 
See Figure \ref{img:exskip}.
The first part of the code ($1~0~0$) indicates that the first edge
contains no exon at all. The first symbol of this code part
indicates the edge number, the second symbol the node rank within 
the bubble and the third symbol the node type. The second part of 
the splicing code ($2~1 - 2~2~\wedge$) represents edge number 2 
containing exactly one exon described by the flanking nodes
$-$ and $\wedge$. 

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=\textwidth]{exskip.png}
  \end{center}
  \caption{Splicing graph representation of an 1 exon skip leading to
    one bubble. The associated splicing code is 
    $1~0~0~2~1 - 2~2~\wedge$. Left: splicing graph
    representation. Right: transcript representation
  }
  \label{img:exskip}
\end{figure}

Another example where disjoining comes into play is a
an alternative splicing site acceptor in one of two transcripts.
The code for an alternative splicing site acceptor would be 
$1~0~0~2~1 - 2~2~{\wedge}{:}$ and can be seen as an exon 
skip where the end of the exon is linked to a disjoint site. 
In such a way it is possible to characterize and to
distinguish a variety of different splicing events. 
See Figure \ref{img:altaccept}

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=\textwidth]{altaccept.png}
  \end{center}
  \caption{Splicing graph representation of an alternative acceptor site
    leading to one bubble. The associated splicing code is
    $1~0~0~2~1 - 2~2~{\wedge}{:}$. 
    Left: splicing graph representation. Right: transcript representation
  }
  \label{img:altaccept}
\end{figure}

\subsection{Tabulating all the alternative splicing codes for Mouse
            chromosome 19}

\begin{small}
<<AScode_summary>>=
AScode_list <- lapply(seq_along(sg), function(i) bubbles(sg[i])$AScode)
names(AScode_list) <- names(sg)
AScode_table <- table(unlist(AScode_list))
AScode_table <- sort(AScode_table, decreasing=TRUE)
AScode_summary <- data.frame(AScode=names(AScode_table),
                             NbOfEvents=as.vector(AScode_table),
                             Desciption=ASCODE2DESC[names(AScode_table)])
nrow(AScode_summary)
@
\end{small}

\begin{small}
<<head_AScode_summary>>=
head(AScode_summary, n=10)
@
\end{small}

Amongst the \Sexpr{nrow(AScode_summary)} distinct complete events we observe
on Mouse chromosome 19, the most frequent one is named ``skip 1 exon''.
At this point it should be mentioned that not all splicing
events have names since there are a variety of different events.

Another interesting information which we can gain from the splicing
graph is how many complete events does each individual gene have.
To answer this we have to count the number of bubbles within
each gene.

<<nb_bubbles_per_gene>>=
nb_bubbles_per_gene <- elementLengths(AScode_list)
@ 

Below the genes with the most observed splicing events are shown.

<<head_sort_nb_bubbles_per_gene>>=
head(sort(nb_bubbles_per_gene, decreasing=TRUE))
@ 

Next we want to see which genes show the highest heterogeneity of splicing
events.
We check for the number of unique splicing events for each gene.

<<nb_unique_bubbles_per_gene>>=
nb_unique_bubbles_per_gene <- elementLengths(unique(CharacterList(AScode_list)))
@ 

Below the genes with the highest heterogeneity in observed splicing events
are shown

<<head_sort_nb_unique_bubbles_per_gene>>=
head(sort(nb_unique_bubbles_per_gene, decreasing=TRUE))
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Counting reads}

[TODO: Complete this section.]

This section deals with counting the reads associated with the
individual edges. To elucidate later in this vignette some
advantages of the splicing graph approach the reads for the 
exon model get also counted. As a starting point for counting the 
aligned reads are required. The aligned reads used in this example 
are stored as BAM files. The BAM files used for counting reads are
provided in the \Rpackage{TBX20BamSubset}.
The \Rfunction{countSpliceGraphReads} function 
requires a \Rclass{BamFileList} object which is created out of the
the file paths to the six selected BAM files.

<<bam_files>>=
library(TBX20BamSubset)
bam_files <- getBamFileList()
@ 

\subsection{Assigning reads to a \Rclass{SplicingGraphs} object}

We can use the \Rcode{assignReads} function to assign reads to the
exons and introns in \Rclass{SplicingGraphs} object \Rcode{sg}.
Note that the same read can be assigned to more than one exon or
intron (e.g. a junction read with 1 gap can be assigned to 2 exons
and 1 intron).

[TODO: Try to optimize assignReads() so we can do the full count below
 in reasonable time.]

In order to keep things running in a reasonable time in this vignette,
we reduce the size of \Rclass{SplicingGraphs} object \Rcode{sg} by
keeping only 50 randomly chosen genes:

<<sg50>>=
set.seed(33)
sg50 <- sample(sg, 50)
@

We're also going to use only 20\% (randomly sampled) of the reads
from each BAM file.

<<assignReads,eval=FALSE>>=
library(Rsamtools)
flag0 <- scanBamFlag(isNotPrimaryRead=FALSE,
                     isNotPassingQualityControls=FALSE,
                     isDuplicate=FALSE)
param0 <- ScanBamParam(flag=flag0)
## The following loop takes about 10 minutes!
for (i in seq_along(bam_files)) {
    bam_file <- bam_files[i]
    cat("Processing sample ", names(bam_file), " ... ", sep="")
    gal0 <- readGappedAlignments(bam_file, use.names=TRUE, param=param0)
    gal <- sample(gal0, length(gal0) * 0.2)
    grl <- grglist(gal, order.as.in.query=TRUE)
    sg50 <- assignReads(sg50, grl, sample.name=names(bam_file))
    cat("OK\n")
}
@
<<loadPrecomputed_sg50,echo=FALSE>>=
sg50 <- .loadPrecomputed("sg50")
@

\subsection{Counting the number of reads per splicing graph edge}

<<countReads_sg50,eval=FALSE>>=
## Takes about 1 minute...
sg50_counts <- countReads(sg50)
@
<<loadPrecomputed_sg50_counts,echo=FALSE>>=
sg50_counts <- .loadPrecomputed("sg50_counts")
@

The returned object is a \Rclass{DataFrame} with one row per unique
splicing graph edge and one column of counts per sample. Two additional
columns contain the splicing graph edge ids and the type of edge (exon
or intron):

\begin{small}
<<head_sg50_counts>>=
dim(sg50_counts)
head(sg50_counts)
@
\end{small}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session Information}

All of the output in this vignette was produced under the following
conditions:

\begin{small}
<<SessionInfo>>=
sessionInfo()
@
\end{small}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{}

\bibitem{Sammeth:2010}
{Michael Sammeth}.
\newblock Complete Alternative Splicing Events Are Bubbles in Splicing Graphs
\newblock {\em Computational Biology}, \textbf{16}, 1117-1140, 2010.

\bibitem{Sakabe:2012}
{Sakabe, Noboru J.} and {Aneas, Ivy} and {Shen, Tao} and {Shokri, Leila} and {Park, Soo-Young} and {Bulyk, Martha L.} and {Evans, Sylvia M.} and {Nobrega, Marcelo A.}
\newblock Dual transcriptional activator and repressor roles of TBX20 regulate adult cardiac structure and function
\newblock {\em Human Molecular Genetics}, \textbf{21}(10), 2194-2204, 2012.

\bibitem{RSEM2011}
{LI, Bo} and {Dewey, Colin}.
\newblock RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome
\newblock {\em BMC Bioinformatics}, \textbf{12}(1), 323, 2011.

\bibitem{Roberts:2011}
{Roberts, Adam} and {Pimentel, Harold} and {Trapnell, Cole} and {Pachter, Lior}.
\newblock Identification of novel transcripts in annotated genomes using RNA-Seq
\newblock {\em BIOINFORMATICS}, 2011

\bibitem{Anders:2010}
{Simon Anders} and {Wolfgang Huber}.
\newblock {D}ifferential expression analysis for sequence count data
\newblock {\em Genome Biology}, \textbf{11}, R106, 2010.

\bibitem{Heber:2002}
{Heber, Steffen} and {Alekseyev, Max} and {Sze, Sing-Hoi} and {Tang, Haixu} and {Pevzner, Pavel A.}
\newblock Splicing graphs and EST assembly problem
\newblock {\em Bioinformatics}, \textbf{18}(suppl 1), S181-S188, 2002.

\end{thebibliography}

\end{document}

