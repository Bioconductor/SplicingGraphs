%\VignetteIndexEntry{Splicing graph analysis of RNA-Seq data}
%\VignetteDepends{SplicingGraphs,TxDb.Mmusculus.UCSC.mm9.knownGene,TBX20BamSubset,Rsamtools}
%\VignetteKeywords{Annotation}
%\VignettePackage{SplicingGraphs}
\documentclass[11pt]{article}

\usepackage{url}
\usepackage{float}
\usepackage{xcolor}

\usepackage[margin=1in]{geometry}

\setlength{\parindent}{0pt}

\usepackage{enumitem}
\setlist{nolistsep}

\usepackage[margin=0.75in]{caption}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\texttt{#1}}}
\newcommand{\Rfunarg}[1]{{\texttt{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\software}[1]{\textsf{#1}}
\newcommand{\R}{\software{R}}
\newcommand{\Bioconductor}{\software{Bioconductor}}

\bibliographystyle{plainnat}

\SweaveOpts{keep.source=TRUE}

\title{Splicing graph analysis of RNA-Seq data}

\author{Martin Morgan\and
  Marc Carlson\and
  Daniel Bindreither\and
  Herv\'e Pag\`es}

\date{Last modified: March 2013; Compiled: \today}

\begin{document}

\maketitle

<<settings,echo=FALSE>>=
.precomputed_results <- system.file("doc", "precomputed_results",
                                    package="SplicingGraphs", mustWork=TRUE)
.loadPrecomputed <- function(objname)
{
    filename <- paste0(objname, ".rda")
    path <- file.path(.precomputed_results, filename)
    tempenv <- new.env(parent=emptyenv())
    load(path, envir=tempenv)
    get(objname, envir=tempenv)
}
@ 

\tableofcontents

\setlength{\parskip}{\baselineskip}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \Rpackage{SplicingGraphs} package allows the user to create and
manipulate splicing graphs \cite{Sammeth:2010} based on annotations
for a given organism. The annotations must describe a \textit{gene model},
that is, they must contain the following information:
\begin{itemize}
  \item The exact exon/intron structure (i.e. genomic coordinates)
        for the known transcripts.
  \item The grouping of transcripts by gene.
\end{itemize}

The annotations need to be provided as a \Rclass{TranscriptDb} or
\Rclass{GRangesList} object, which is how a gene model is typically
represented in \Bioconductor.

Additionally the package allows the user to assign RNA-Seq reads to
a SplicingGraphs object, and to count them. This requires that the
reads have been previously aligned to the exact same reference genome
that the gene model is based on. RNA-Seq data from an already published
study is used to illustrate this functionality. The study, performed on
\textit{Mus musculus}, compares TBX20 (T-box protein 20) knock-out
with wilde type heart tissue samples \cite{Sakabe:2012}.

%Although there exist several software solutions for RNA-Seq 
%based transcriptome analysis, like RSEM \cite{RSEM2011},
%Cufflinks \cite{Roberts:2011} or the R package \Rpackage{DEXSeq} 
%\cite{Anders:2010}, the approach of analyzing splicing events as
%complete complex structure is still new. 

[TODO: Remove the following TEMPORARY NOTE before BioC 2.12 release.]

TEMPORARY NOTE: The scope of the new \Rpackage{SplicingGraphs} package
has been reduced roughly to the following functionalities:
creating/manipulating/plotting splicing graphs, computing the bubbles
and AS codes, and counting reads. In particular anything in the old
\Rpackage{SpliceGraph} package that was related to the downstream
statistical analysis has been dropped. As a consequence the following
topics/sections from the old \Rpackage{SpliceGraph} vignette are not
covered in this vignette:
\begin{itemize}
  \item ``The experimental design''
  \item ``Significant altered alternative splice events''
  \item Modification of GLM employed in the \Rpackage{DEXSeq} package.
  \item ``Differential edge expression analysis''
  \item Comparison to the classic \Rpackage{DEXSeq} analysis.
\end{itemize}
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Splicing graphs}

Alternative splicing is a frequently observed complex biological 
process which modifies the primary RNA transcript and leads to 
transcript variants of genes. Those variants can often be plentiful. 
Especially for large genes it is often difficult to describe their
structure in a formal, logical, short and convenient way. To capture 
the full variety of splicing variants of a certain gene in one single 
data structure, Heber at al \cite{Heber:2002} introduced the term 
\textit{splicing graph} and provided a formal framework for representing
the different choices of the splicing machinery. 

\subsection{Definitions and example}

For a comprehensive explanation of the splicing graph theory,
please refer to \cite{Heber:2002} and \cite{Sammeth:2010}.

A splicing graph is a directed acyclic graph (DAG) where:
\begin{itemize}
  \item The vertices (a.k.a. \textit{nodes}) represent the splicing sites
        for a given gene. Splicing sites are ordered by their position from
        5' to 3' and numbered from \Rcode{1} to \Rcode{n}. This number
        is the \textit{Splicing Site id}.
        Note that splicing graphs are only defined for genes that have all
        the exons of all their transcripts on the same chromosome and
        strand. In particular, in its current form, the splicing graph
        theory cannot describe \textit{trans-plicing} events.
  \item The edges are the exons and introns between the splicing sites.
        Their orientation follows the 5' to 3' direction i.e. they go
        from low to high \textit{Splicing Site ids}.
\end{itemize}

Two artificial nodes that don't correspond to any splicing site
are added to the graph: the \textit{root} (\Rcode{R}) and the \textit{leaf}
(\Rcode{L}). Also artificial edges are added so that all the transcripts are
represented by a path that goes from \Rcode{R} to \Rcode{L}. That way the
graph is connected. Note that not all paths in the graph are necessarily
supported by a transcript.

Figure \ref{img:CIB3} shows the splicing graph representation
of all known transcript variants of Human gene CIB3 (Entrez ID 117286).

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=90,origin=lB]{CIB3-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the four transcript variants
    of gene CIB3 (Entrez ID 117286).
    Left: transcript representation. Right: splicing graph representation.
    The orange arrows are edges corresponding to exons.
  }
  \label{img:CIB3}
\end{figure}

\subsection{Details about nodes and edges}

Splicing sites can be of the following types:
\begin{itemize}
  \item \textit{acceptor} site (symbol: $-$);
  \item \textit{donor} site (symbol: $\wedge$);
  \item \textit{transcription start} site (symbol: $~[~$);
  \item \textit{transcription end} site (symbol: $~]~$).
\end{itemize}

The symbols associated with the individual types of nodes shown in braces 
above are used for the identification of complete alternative splicing
events. For more information about gathering the alternative splicing
events and their associated splicing codes, please refer to
\cite{Heber:2002} and \cite{Sammeth:2010}.

In some cases a given splicing site can be associated with 2 types
but the combinations of types for such sites is limited.
Only \textit{acceptor} ($-$) and \textit{transcription start} ($~[~$),
or \textit{donor} ($\wedge$) and \textit{transcription end} ($~]~$), can
occur as a pair of types. Such a dual-type node occurs when the start
of an exon, which is not the first exon of a transcript, falls together
with the transcription start site of another transcript of the same gene.
An example of such splicing graph is shown in Figure \ref{img:ZNF813}.

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=4in,height=1.5in,angle=-90,origin=rB]{ZNF813-transcripts.pdf}
  \hskip 0.5in
  \raisebox{-0.6in}{\includegraphics[width=3in,height=5.5in]{ZNF813-sg.pdf}}
  \end{center}
  \caption{Splicing graph representation of the two transcript variants
    of Human gene ZNF813 (Entrez ID 126017). Node $3$ is a ($-$,$~[~$)
    dual-type node: \textit{acceptor} ($-$) for transcript {\tt uc002qbu.2},
    and \textit{transcription start} ($~[~$) for transcript {\tt uc010eqq.1}.
  }
  \label{img:ZNF813}
\end{figure}

A similar case occurs when the end of an exon, which is not the last
exon of a transcript, falls together with the transcription end site
of another transcript of the same gene.

Whether a non-artificial edge represents an exon or an intron is
determined by the types of its two flanking nodes:
\begin{itemize}
  \item \textbf{exon} if going from \textit{acceptor} ($-$), or
        ($-$,$~[~$) dual-type, to \textit{donor} ($\wedge$), or
        ($\wedge$,$~]~$) dual-type;
  \item \textbf{intron} if the otherway around.
\end{itemize}

\subsection{Uninformative nodes}

Not all splicing sites (nodes) on the individual transcripts are alternative 
splicing sites. Therefore the initial splicing graph outlined above can be
simplified by removing nodes of in- and out- degree equal to one because
they are supposed to be non-informative in terms of alternative splicing.
Edges associated with such nodes get sequentially merged with
the previous ones and result in longer edges capturing adjacent
exons/introns. The final splicing graph only contains nodes involved in
alternative splicing. The result of removing uninformative nodes is
illustrated in Figure \ref{img:CIB3-simplified}.

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=2in,height=5.5in]{CIB3-sg.pdf}
  \hskip 0.5in
  \includegraphics[width=2in,height=5.5in]{CIB3-sg2.pdf}
  \end{center}
  \caption{Nodes \Rcode{1}, \Rcode{3}, \Rcode{5}, \Rcode{6}, \Rcode{9},
    \Rcode{11}, \Rcode{12}, and \Rcode{13}, are uninformative and can be
    removed. Left: before removal of the uninformative nodes. Right: after
    their removal.
  }
  \label{img:CIB3-simplified}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing splicing graphs from annotations}


\subsection{Choosing and loading a gene model}

The starting point for computing splicing graphs is a set of annotations
describing a \textit{gene model} for a given organism. In \Bioconductor,
a gene model is typically represented as a \Rclass{TranscriptDb}.
A few prepackaged \Rclass{TranscriptDb} objects are available as
\Rpackage{TxDb.*} annotation packages in the \Bioconductor package
repositories. Here the \Rpackage{TxDb.Mmusculus.UCSC.mm9.knownGene}
package is used. Note that if there is no prepackaged \Rclass{TranscriptDb}
object for the genome/track that the user wants to use, such objects can
easily be created by using tools from the \Rpackage{GenomicFeatures} 
package.

First we load the \Rpackage{TxDb.*} package:

<<txdb>>=
library(TxDb.Mmusculus.UCSC.mm9.knownGene)
txdb <- TxDb.Mmusculus.UCSC.mm9.knownGene
@

Creating the splicing graphs for all the genes in the \Rclass{TranscriptDb}
object can take a long time (up to 20 minutes or more). In order to keep
things running in a reasonable time in this vignette, we restrict the gene
model to the genes located on chromosome 19. Let's use the
\Rfunction{isActiveSeq} getter/setter for this. By default, all the
chromosomes in a \Rclass{TranscriptDb} object are ``active'':

\begin{small}
<<isActiveSeq>>=
isActiveSeq(txdb)
@
\end{small}

Next we set all the values in this named logical vector to \Rcode{FALSE},
except the value for \Rcode{chr19}:

<<keep_chr19_only>>=
isActiveSeq(txdb)[-match("chr19", names(isActiveSeq(txdb)))] <- FALSE
names(which(isActiveSeq(txdb)))
@

\subsection{Generating a \Rclass{SplicingGraphs} object}

Splicing graphs are computed by calling the \Rfunction{SplicingGraphs}
function on the gene model. This is the constructor function for
\Rclass{SplicingGraphs} objects. It will compute information about all
the splicing graphs (1 per gene) and store it in the returned object.

<<sg>>=
library(SplicingGraphs)
sg <- SplicingGraphs(txdb)
sg
@
%% We load a precomputed 'sg' that contains all the bubbles in its
%% bubbles_cache slot.
<<loadPrecomputed_sg,echo=FALSE>>=
sg2 <- .loadPrecomputed("sg")
sg@.bubbles_cache <- sg2@.bubbles_cache
if (!identical(sg, sg2))
    stop("'sg' is not identical to precomputed version")
@

\Rcode{sg} is a \Rclass{SplicingGraphs} object. It has 1 element per
gene and \Rcode{names(sg)} gives the gene ids:

<<names_sg>>=
names(sg)[1:20]
@

\Rcode{seqnames(sg)} and \Rcode{strand(sg)} return the chromosome and
strand of the genes:

<<seqnames_sg>>=
seqnames(sg)[1:20]
strand(sg)[1:20]
table(strand(sg))
@

The number of transcripts per gene can be obtained with
\Rcode{elementLengths(sg)}:

<<elementLengths_sg>>=
elementLengths(sg)[1:20]
@

\Rfunction{elementLengths} is a core accessor for list-like objects
that returns the lengths of the individual list elements.

At this point you might wonder why \Rfunction{elementLengths} works on
\Rclass{SplicingGraphs} objects. Does this mean that those objects are
list-like objects? The answer is yes. The next thing you might wonder
is what do the list elements look like and how you can access them.
This is answered in the next subsection.

\subsection{Basic manipulation of a \Rclass{SplicingGraphs} object}

The list elements of a list-like object can be accessed \textbf{one
at a time} by subsetting the object with \Rfunction{[[} (a.k.a.
double-bracket subsetting). On a \Rclass{SplicingGraphs} object,
this will extract the transcripts of a given gene. More precisely
it will return an \textbf{unnamed} \Rclass{GRangesList} object
containing the exons of the gene grouped by transcript:

\begin{small}
<<sg_double_bracket_107328>>=
sg[["107328"]]
@
\end{small}

The exon-level metadata columns are:
\begin{itemize}
  \item \Rcode{exon\_id}: The original internal exon id as stored in the
        \Rclass{TranscriptDb} object. This id was created and assigned to
        each exon when the \Rclass{TranscriptDb} object was created.
        It's not a public id like, say, an Ensembl, RefSeq, or GenBank id.
        Furthermore, it's only guaranteed to be unique within a
        \Rclass{TranscriptDb} object.
  \item \Rcode{exon\_name}: The original exon name as provided by the
        annotation resource (e.g. UCSC, Ensembl, or GFF file) and stored
        in the \Rclass{TranscriptDb} object when it was created.
        Set to \Rcode{NA} if no exon name was provided.
  \item \Rcode{exon\_rank}: The rank of the exon in the transcript.
  \item \Rcode{start\_SSid}, \Rcode{end\_SSid}: The \textit{Splicing Site
        ids} corresponding to the \textit{start} and \textit{end} coordinates
        of the exon. (Please be cautious to not misinterpret the meaning
        of \textit{start} and \textit{end} here. See IMPORTANT NOTE below.)
        Those ids were assigned by the \Rfunction{SplicingGraphs} constructor.
\end{itemize}

IMPORTANT NOTE: Please be aware that the \textit{start} and \textit{end}
coordinates of an exon, like the \textit{start} and \textit{end}
coordinates of a genomic range in general, are following the almost
universal convention that \textit{start} is $<=$ \textit{end}, and this
\textbf{regardless of the direction of transcription}.

As mentioned previously, the \textit{Splicing Site ids} are assigned based
on the order of the site positions from 5' to 3'. This means that, for a
gene on the plus (resp. minus) strand, the ids in the \Rcode{start\_SSid}
metadata column are always lower (resp. greater) than those in the
\Rcode{end\_SSid} metadata column.

\begin{small}
<<sg_double_bracket_104252>>=
sg[["104252"]]
@
\end{small}

However, on both strands, the \textit{Splicing Site id} increases with the
rank of the exon.

The \Rfunction{show} method for \Rclass{GRangesList} objects only
displays the inner metadata columns (which are at the exon level for
objects like \Rcode{sg[["107328"]]}). To see the outer metadata columns
(transcript-level metadata columns for objects like \Rcode{sg[["107328"]]}),
we need to extract them explicitely:

<<mcols_sg_double_bracket_107328>>=
mcols(sg[["107328"]])
@

The transcript-level metadata columns are:
\begin{itemize}
  \item \Rcode{tx\_id}: The original transcript id as provided by the
        annotation resource (e.g. UCSC, Ensembl, or GFF file) and stored
        in the \Rclass{TranscriptDb} object when it was created.
  \item \Rcode{txpath}: A named list-like object with one list element
        per transcript in the gene. Each list element is an integer vector
        that describes the \textit{path} of the transcript i.e. the
        \textit{Splicing Site ids} that it goes thru.
\end{itemize}

<<mcols_sg_double_bracket_107328>>=
mcols(sg[["107328"]])$txpath
mcols(sg[["104252"]])$txpath
@

A more convenient way to extract this information is to use the
\Rfunction{txpath} accessor:

<<txpath_sg_104252>>=
txpath(sg[["104252"]])
@

Note that the list elements of the \Rcode{txpath} metadata column
always consist of an even number of \textit{Splicing Site ids} in
ascending order.

The transcripts in a \Rclass{GRangesList} object like \Rcode{sg[["107328"]]}
can be plotted with \Rfunction{plotTranscripts}:

<<plotTranscripts_sg_107328,eval=FALSE>>=
plotTranscripts(sg[["107328"]])
@

The resulting plot is shown on figure \ref{img:107328-transcripts}.

<<plotTranscripts_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-transcripts.pdf", width=6, height=3)
plotTranscripts(sg[["107328"]])
dev.off()
@
\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=6in,height=3in]{107328-transcripts.pdf}
  \end{center}
  \caption{The 3 transcripts of gene 107328 (Entrez ID).}
  \label{img:107328-transcripts}
\end{figure}

\Rclass{SplicingGraphs} objects, like most list-like objects, can be
unlisted with \Rfunction{unlist}. This will extract the transcripts of
all the genes and return them as a \textbf{named} \Rclass{GRangesList}
object. The names on the object are the gene ids:

<<unlist_sg>>=
ex_by_tx <- unlist(sg)
head(names(ex_by_tx))
@

Note that, because each element in the object represents a transcript
(and not a gene), the names are not unique! This means that trying to
subset the object by name (e.g. with \Rcode{ex\_by\_tx["107328"]}
or \Rcode{ex\_by\_tx[["107328"]]}) is probably a bad idea because this
will only select the first element with that name.
When the names on a vector-like object \Rcode{x} are not unique, a safe
way to select the elements with some given names is to do something like
\Rcode{x[names(x) \%in\% c("name1", "name2")]}.
For example, to select transcripts from genes 107328 and 104252:

\begin{small}
<<unlist_sg>>=
ex_by_tx[names(ex_by_tx) %in% c("107328", "104252")]
@
\end{small}

\subsection{Extracting and plotting graphs from a \Rclass{SplicingGraphs}
            object}

The edges (resp. nodes) of the splicing graph of a given gene can be
extracted with the \Rfunction{sgedges} (resp. \Rfunction{sgnodes})
function. An important caveat is that this can only be done for one
gene at a time, or, said otherwise, these functions only work on a
\Rclass{SplicingGraphs} object of length 1. Here is where subsetting
with \Rfunction{[} (a.k.a. single-bracket subsetting) comes into play.

Using \Rfunction{[} on a \Rclass{SplicingGraphs} object returns a
\Rclass{SplicingGraphs} object containing only the selected genes:

<<single_bracket_subsetting>>=
sg[strand(sg) == "-"]
sg[1:20]
tail(sg)  # equivalent to 'sg[tail(seq_along(sg))]'
sg["107328"]
@

Let's extract the splicing graph edges for gene 107328 (Entrez ID):

<<sgedges_sg_107328>>=
sgedges(sg["107328"])
@

The \Rclass{DataFrame} object returned by \Rfunction{sgedges} has 1 row
per edge. Its columns are explained below.

Let's extract the splicing graph nodes for that gene:

<<sgnodes_sg_107328>>=
sgnodes(sg["107328"])
@

The character vector returned by \Rfunction{sgnodes} contains the node
ids, that is, \Rcode{R} and \Rcode{L} for the \textit{root} and \textit{leaf}
nodes, and the \textit{Splicing Site ids} for the other nodes.
The node ids are always returned in ascending order with \Rcode{R} and
\Rcode{L} being always the first and last nodes, respectively.

The \Rclass{DataFrame} object returned by \Rfunction{sgedges} has the
following columns:
\begin{itemize}
  \item \Rcode{from}, \Rcode{to}: The 2 nodes connected by the edge.
  \item \Rcode{ex\_or\_in}: The type of the edge i.e. exon, intron, or
        no type if it's an artificial edge.
  \item \Rcode{tx\_id}: The ids of the transcripts that support the edge.
\end{itemize}

Alternatively the splicing graph edges of all the genes can be extracted
with \Rfunction{sgedgesByTranscript}:

<<sgedgesByTranscript_sg>>=
edges_by_tx <- sgedgesByTranscript(sg)
@

In that case they are returned in a named \Rclass{GRangesList} object
where they are grouped by transcript. The names on the object are the
gene ids. As we've seen previously with \Rfunction{unlist}, the
names are not unique. Let's look at the elements in \Rcode{edges\_by\_tx}
that correspond to gene 104252:

\begin{small}
<<edges_by_tx_subset>>=
edges_by_tx[names(edges_by_tx) %in% "104252"]
@
\end{small}

The edge-level metadata columns are the following:
\begin{itemize}
  \item \Rcode{sgedge\_id}: A global edge id of the form
        \Rcode{gene\_id:from,to}.
  \item \Rcode{from}, \Rcode{to}, \Rcode{ex\_or\_in}, \Rcode{tx\_id}:
        See the columns of the \Rclass{DataFrame} object returned
        by \Rfunction{sgedges}.
  \item \Rcode{exon\_id}, \Rcode{exon\_name}, \Rcode{exon\_rank},
        \Rcode{start\_SSid}, \Rcode{end\_SSid}: See the exon-level
        metadata columns returned by \Rcode{sg[["some\_gene\_id"]]}
        (or \Rcode{unlist(sg)}). Set to \Rcode{NA} for edges of type
        intron.
\end{itemize}

Note that the artificial edges (i.e. edges starting from the root
node (\Rcode{R}) or ending at the leaf node (\Rcode{L})) are omitted!

Finally, to plot a given splicing graph:

<<plot_sg_107328,eval=FALSE>>=
plot(sgraph(sg["107328"]))
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
@

The resulting plots are shown on figure \ref{img:107328-sgraph}.

<<plot_sg_107328_as_pdf,echo=FALSE,results=hide>>=
pdf("107328-sgraph.pdf", width=3, height=5)
plot(sgraph(sg["107328"]))
dev.off()
pdf("107328-sgraph-labelled.pdf", width=3, height=5)
plot(sgraph(sg["107328"], tx_id.as.edge.label=TRUE))
dev.off()
@
\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=3in,height=5in]{107328-sgraph.pdf}
  \hskip 0.25in
  \includegraphics[width=3in,height=5in]{107328-sgraph-labelled.pdf}
  \end{center}
  \caption{Splicing graph representation of gene 107328 (Entrez ID).
    Left: unlabelled edges. Right: edge labelled with the transcript
    ids (or names).
  }
  \label{img:107328-sgraph}
\end{figure}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Splicing graph bubbles}

\subsection{Some definitions}

The definition of a bubble provided in Sammeth's paper \cite{Sammeth:2010}
is quite obfuscated. Here we try to give a simpler one.
For that purpose, we start by introducing the notion of \textit{set of
supporting transcripts of a splicing graph node $s$}: this is the set
of transcripts in the gene that ``go thru'' $s$, or, said otherwise,
that have $s$ in their path (see the \Rfunction{txpath} function in
previous section for how to extract the transcript paths). It's denoted
$transcripts(s)$.

Now the definition of a bubble: there is a ``bubble'' between 2 nodes $s$
and $t$ ($s < t$ ) of a splicing graph if (a) there are at least 2 distinct
paths going from $s$ to $t$, and (b) there is no node $u$ between $s$ and $t$
such that $transcripts(u)$ contains $transcripts(s) \cap transcripts(t)$.
The bubble between $s$ and $t$ is then the subgraph made of all the paths
going from $s$ to $t$. Nodes $s$ and $t$ are said to be the ``source''
and``sink'' of the bubble. The number of distinct paths going from $s$
to $t$ is the ``dimension'' of the bubble.

\subsection{Computing the bubbles of a splicing graph}

Like with the \Rfunction{sgedges} and \Rfunction{sgnodes} functions,
the bubbles can only be computed for one gene/graph at a time.
Let's compute all the bubbles for gene 107328 (Entrez ID):

<<bubbles_sg_107328>>=
bubbles(sg["107328"])
@

[TODO: Describe the output of bubbles().]

\subsection{Interpretation of the alternative splicing codes}

[TODO: Revisit this subsection entirely.]

Splicing codes can be obtained by iterating over the individual
bubbles and collecting the types of the original nodes associated 
with the individual bubble edges and their ranks. This section
makes use of simple toy examples to describe how the splicing code can 
be interpreted in terms of well known splicing mechanisms like exon 
skipping, alternative promotor usage, intron retention, etc.

An example read out of a bubble could reveal the splicing code 
($1~0~0~2~1 - 2~2~\wedge$ ) which would represent an 1 exon skip. 
See Figure \ref{img:exskip}.
The first part of the code ($1~0~0$) indicates that the first edge
contains no exon at all. The first symbol of this code part
indicates the edge number, the second symbol the node rank within 
the bubble and the third symbol the node type. The second part of 
the splicing code ($2~1 - 2~2~\wedge$) represents edge number 2 
containing exactly one exon described by the flanking nodes
$-$ and $\wedge$. 

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=\textwidth]{exskip.png}
  \end{center}
  \caption{Splicing graph representation of an 1 exon skip leading to
    one bubble. The associated splicing code is 
    $1~0~0~2~1 - 2~2~\wedge$. Left: splicing graph
    representation. Right: transcript representation
  }
  \label{img:exskip}
\end{figure}

Another example where disjoining comes into play is a
an alternative splicing site acceptor in one of two transcripts.
The code for an alternative splicing site acceptor would be 
$1~0~0~2~1 - 2~2~{\wedge}{:}$ and can be seen as an exon 
skip where the end of the exon is linked to a disjoint site. 
In such a way it is possible to characterize and to
distinguish a variety of different splicing events. 
See Figure \ref{img:altaccept}

\begin{figure}[!htbp]
  \begin{center}
  \includegraphics[width=\textwidth]{altaccept.png}
  \end{center}
  \caption{Splicing graph representation of an alternative acceptor site
    leading to one bubble. The associated splicing code is
    $1~0~0~2~1 - 2~2~{\wedge}{:}$. 
    Left: splicing graph representation. Right: transcript representation
  }
  \label{img:altaccept}
\end{figure}

\subsection{Tabulating all the alternative splicing codes for Mouse
            chromosome 19}

\begin{small}
<<AScode_summary>>=
AScode_list <- lapply(seq_along(sg), function(i) bubbles(sg[i])$AScode)
names(AScode_list) <- names(sg)
AScode_table <- table(unlist(AScode_list))
AScode_table <- sort(AScode_table, decreasing=TRUE)
AScode_summary <- data.frame(AScode=names(AScode_table),
                             NbOfEvents=as.vector(AScode_table),
                             Desciption=ASCODE2DESC[names(AScode_table)])
nrow(AScode_summary)
@
\end{small}

\begin{small}
<<head_AScode_summary>>=
head(AScode_summary, n=10)
@
\end{small}

Amongst the \Sexpr{nrow(AScode_summary)} distinct complete events we observe
on Mouse chromosome 19, the most frequent one is named ``skip 1 exon''.
At this point it should be mentioned that not all splicing
events have names since there are a variety of different events.

Another interesting information which we can gain from the splicing
graph is how many complete events does each individual gene have.
To answer this we have to count the number of bubbles within
each gene.

<<nb_bubbles_per_gene>>=
nb_bubbles_per_gene <- elementLengths(AScode_list)
@ 

Below the genes with the most observed splicing events are shown.

<<head_sort_nb_bubbles_per_gene>>=
head(sort(nb_bubbles_per_gene, decreasing=TRUE))
@ 

Next we want to see which genes show the highest heterogeneity of splicing
events.
We check for the number of unique splicing events for each gene.

<<nb_unique_bubbles_per_gene>>=
nb_unique_bubbles_per_gene <- elementLengths(unique(CharacterList(AScode_list)))
@ 

Below the genes with the highest heterogeneity in observed splicing events
are shown

<<head_sort_nb_unique_bubbles_per_gene>>=
head(sort(nb_unique_bubbles_per_gene, decreasing=TRUE))
@ 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Counting reads}

[TODO: Complete this section.]

This section deals with counting the reads associated with the
individual edges. To elucidate later in this vignette some
advantages of the splicing graph approach the reads for the 
exon model get also counted. As a starting point for counting the 
aligned reads are required. The aligned reads used in this example 
are stored as BAM files. The BAM files used for counting reads are
provided in the \Rpackage{TBX20BamSubset}.
The \Rfunction{countSpliceGraphReads} function 
requires a \Rclass{BamFileList} object which is created out of the
the file paths to the six selected BAM files.

<<bam_files>>=
library(TBX20BamSubset)
bam_files <- getBamFileList()
@ 

\subsection{Assigning reads to a \Rclass{SplicingGraphs} object}

We can use the \Rcode{assignReads} function to assign reads to the
exons and introns in \Rclass{SplicingGraphs} object \Rcode{sg}.
Note that the same read can be assigned to more than one exon or
intron (e.g. a junction read with 1 gap can be assigned to 2 exons
and 1 intron).

[TODO: Try to optimize assignReads() so we can do the full count below
 in reasonable time.]

In order to keep things running in a reasonable time in this vignette,
we reduce the size of \Rclass{SplicingGraphs} object \Rcode{sg} by
keeping only 50 randomly chosen genes:

<<sg50>>=
set.seed(33)
sg50 <- sample(sg, 50)
@

We're also going to use only 20\% (randomly sampled) of the reads
from each BAM file.

<<assignReads,eval=FALSE>>=
library(Rsamtools)
flag0 <- scanBamFlag(isNotPrimaryRead=FALSE,
                     isNotPassingQualityControls=FALSE,
                     isDuplicate=FALSE)
param0 <- ScanBamParam(flag=flag0)
## The following loop takes about 10 minutes!
for (i in seq_along(bam_files)) {
    bam_file <- bam_files[i]
    cat("Processing sample ", names(bam_file), " ... ", sep="")
    gal0 <- readGappedAlignments(bam_file, use.names=TRUE, param=param0)
    gal <- sample(gal0, length(gal0) * 0.2)
    grl <- grglist(gal, order.as.in.query=TRUE)
    sg50 <- assignReads(sg50, grl, sample.name=names(bam_file))
    cat("OK\n")
}
@
<<loadPrecomputed_sg50,echo=FALSE>>=
sg50 <- .loadPrecomputed("sg50")
@

\subsection{Counting the number of reads per splicing graph edge}

<<countReads_sg50,eval=FALSE>>=
## Takes about 1 minute...
sg50_counts <- countReads(sg50)
@
<<loadPrecomputed_sg50_counts,echo=FALSE>>=
sg50_counts <- .loadPrecomputed("sg50_counts")
@

The returned object is a \Rclass{DataFrame} with one row per unique
splicing graph edge and one column of counts per sample. Two additional
columns contain the splicing graph edge ids and the type of edge (exon
or intron):

\begin{small}
<<head_sg50_counts>>=
dim(sg50_counts)
head(sg50_counts)
@
\end{small}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Session Information}

All of the output in this vignette was produced under the following
conditions:

\begin{small}
<<SessionInfo>>=
sessionInfo()
@
\end{small}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{thebibliography}{}

\bibitem{Sammeth:2010}
{Michael Sammeth}.
\newblock Complete Alternative Splicing Events Are Bubbles in Splicing Graphs
\newblock {\em Computational Biology}, \textbf{16}, 1117-1140, 2010.

\bibitem{Sakabe:2012}
{Sakabe, Noboru J.} and {Aneas, Ivy} and {Shen, Tao} and {Shokri, Leila} and {Park, Soo-Young} and {Bulyk, Martha L.} and {Evans, Sylvia M.} and {Nobrega, Marcelo A.}
\newblock Dual transcriptional activator and repressor roles of TBX20 regulate adult cardiac structure and function
\newblock {\em Human Molecular Genetics}, \textbf{21}(10), 2194-2204, 2012.

\bibitem{RSEM2011}
{LI, Bo} and {Dewey, Colin}.
\newblock RSEM: accurate transcript quantification from RNA-Seq data with or without a reference genome
\newblock {\em BMC Bioinformatics}, \textbf{12}(1), 323, 2011.

\bibitem{Roberts:2011}
{Roberts, Adam} and {Pimentel, Harold} and {Trapnell, Cole} and {Pachter, Lior}.
\newblock Identification of novel transcripts in annotated genomes using RNA-Seq
\newblock {\em BIOINFORMATICS}, 2011

\bibitem{Anders:2010}
{Simon Anders} and {Wolfgang Huber}.
\newblock {D}ifferential expression analysis for sequence count data
\newblock {\em Genome Biology}, \textbf{11}, R106, 2010.

\bibitem{Heber:2002}
{Heber, Steffen} and {Alekseyev, Max} and {Sze, Sing-Hoi} and {Tang, Haixu} and {Pevzner, Pavel A.}
\newblock Splicing graphs and EST assembly problem
\newblock {\em Bioinformatics}, \textbf{18}(suppl 1), S181-S188, 2002.

\end{thebibliography}

\end{document}

